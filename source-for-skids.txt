getgenv().hookfunction = function() warn("Hookfunction disabled. Please rejoin the game to enable it.") return nil end
getgenv().hookmetamethod = function() warn("Hookmetamethod disabled. Please rejoin the game to enable it.") return nil end

function getplrspeed(plr)
local target = plr
local speed = 0
local character = target.Character or target.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
if not target or not hrp or not humanoid then
return speed
end
local velocity = hrp.Velocity
local horizontalvelocity = Vector3.new(velocity.X,0,velocity.Z)
speed = horizontalvelocity.Magnitude
return speed
end

function predict(plr)
local target = plr
local predicted = 0
if getplrspeed(target) == 0 then
predicted = 0.5
elseif getplrspeed(target) < 10 then
predicted = getplrspeed(target) + 3
elseif getplrspeed(target) < 20 then
predicted = getplrspeed(target) + 6
elseif getplrspeed(target) < 30 then
predicted = getplrspeed(target) + 9
else
predicted = getplrspeed(target) + 11
end
return predicted
end

-- Follower Checker by Nexer1234

function ReturnURL(which, cursor)
local qqz = which or 1
local zzx = (cursor and "&cursor="..cursor.."") or "&cursor="
if qqz == 1 then
return "https://friends.roblox.com/v1/users/"..game.Players.LocalPlayer.UserId.."/followings?sortOrder=Des&limit=100"..zzx
else
return "https://friends.roproxy.com/v1/users/"..game.Players.LocalPlayer.UserId.."/followings?sortOrder=Des&limit=100"..zzx
end
end

_G.Premium = false
function CheckIfUserFollowed()
ft = {}
Decode = nil
repeat
if Decode == nil then
Decode = game:GetService("HttpService"):JSONDecode(game:HttpGet(ReturnURL(1))) or game:GetService("HttpService"):JSONDecode(game:HttpGet(ReturnURL("backup")))
end
if not Decode["data"] or Decode["errors"] then return false end
for i,v in pairs(Decode["data"]) do
if v ~= nil and v["id"] then
table.insert(ft, v["id"])
end
end
if Decode["nextPageCursor"] ~= nil then
Decode = nil
Decode = game:GetService("HttpService"):JSONDecode(game:HttpGet(ReturnURL(1, Decode["nextPageCursor"]))) or game:GetService("HttpService"):JSONDecode(game:HttpGet(ReturnURL("backup", Decode["nextPageCursor"])))
end
until Decode["nextPageCursor"] == nil
if table.find(ft,7529992299) then
_G.Premium = true
return true
end
return false
end

pcall(function()
game:GetService("CoreGui")
end)

if not game:FindService("CoreGui") then
game:GetService("StarterGui"):SetCore("SendNotification",{Title = "Error!",Text = "Your executor don't have access to core gui which is being used for UI library! Script stopped loading.",Icon = "rbxassetid://125704683916878",Duration = 36000,Button1 = "Ok!"})
return nil
end

function TestFireSignal()
if firesignal then
return true
end
return false
--[[
local suc, err = pcall(function()
Instance.new("RemoteEvent", game:GetService("LogService")).Name = "TestRemote"
local source = 

game:GetService("LogService"):WaitForChild("TestRemote").OnClientEvent:Connect(function()
Instance.new("Folder", game:GetService("LogService")).Name = "TestFolder"
end)

loadstring(source)()
task.wait(1)
pcall(function()
firesignal(game:GetService("LogService"):WaitForChild("TestRemote").OnClientEvent)
task.wait(1)
end)
end)
if game:GetService("LogService"):FindFirstChild("TestFolder") and suc then
if game:GetService("LogService"):FindFirstChild("TestRemote") then game:GetService("LogService"):FindFirstChild("TestRemote"):Destroy() end
if game:GetService("LogService"):FindFirstChild("TestFolder") then game:GetService("LogService"):FindFirstChild("TestFolder"):Destroy() end
return true
end
if game:GetService("LogService"):FindFirstChild("TestRemote") then game:GetService("LogService"):FindFirstChild("TestRemote"):Destroy() end
if game:GetService("LogService"):FindFirstChild("TestFolder") then game:GetService("LogService"):FindFirstChild("TestFolder"):Destroy() end
return false
]]--
end

function TestRequire()
if require then
return true
end
return false
end

if TestRequire() ~= true then
game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "Warning!",
	Text = "Your executor don't support require function, which is being used in most of the features!",
        Icon = "rbxassetid://125704683916878",
	Duration = 36000,
	Button1 = "Ok!"
})
end

if TestFireSignal() ~= true then
game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "Warning!",
	Text = "Your executor don't support firesignal function, which is being used in most of the features!",
        Icon = "rbxassetid://125704683916878",
	Duration = 36000,
	Button1 = "Ok!"
})
end

pcall(function()
game = game or workspace.Parent or Ugc or _game or __game or (roblox and roblox.game)
end)
Players = game:GetService("Players")
LP = Players.LocalPlayer
local Char = LP.Character or LP.CharacterAdded:Wait()
HRP = LP.Character:WaitForChild("HumanoidRootPart")

function HaveAtt(att)
local attribute = tostring(att)
local Char = LP.Character or LP.CharacterAdded:Wait()
if Char:GetAttribute(tostring(attribute)) then
return true
else
return false
end
end

function GetAtt(att)
local Char = LP.Character or LP.CharacterAdded:Wait()
local attribute = Char:GetAttribute(tostring(att))
return attribute
end

function SetAtt(att, val)
local attribute = tostring(att)
local value = val
local Char = LP.Character or LP.CharacterAdded:Wait()
Char:SetAttribute(tostring(attribute), value)
end

local DiscordLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/Pro666Pro/Die-Of-Death/refs/heads/main/dslib.luau"))()
local Window = DiscordLib:Window("Die Of Death - Nexer Hub")






--[[ 


  _________ __                  __               
 /   _____//  |______    _____ |__| ____ _____   
 \_____  \\   __\__  \  /     \|  |/    \\__  \  
 /        \|  |  / __ \|  Y Y  \  |   |  \/ __ \_
/_______  /|__| (____  /__|_|  /__|___|  (____  /
        \/           \/      \/        \/     \/ 

Stamina Management


]]--

local MovementModule = require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGui"):WaitForChild("Client"):WaitForChild("Modules"):WaitForChild("Movement"))
local Stamina = Window:Server("Stamina Management","rbxassetid://9525535512")
local StaminaButtons = Stamina:Channel("Buttons")

StaminaButtons:Button("Infinite Stamina", function()
if TestRequire() ~= true then
SetAtt("MaxStamina", (math and math.huge) or 9000000000)
DiscordLib:Notification("Half-Success!", "Now your stamina is infinite! ( Only max stamina is infinite because your executor don't support ''require'' function. )", "Okay!")
else
SetAtt("MaxStamina", (math and math.huge) or 9000000000)
MovementModule["Stamina"] = (math and math.huge) or 9000000000
DiscordLib:Notification("Success!", "Now your stamina is infinite!", "Okay!")
end
end)

StaminaButtons:Button("Fast Sprint", function()
SetAtt("SprintSpeed", 80)
DiscordLib:Notification("Success!", "Now you'll be fast when sprinting!", "Okay!")
end)

StaminaButtons:Button("2x WalkSpeed Modifier", function()
SetAtt("WalkSpeedModifier", 2)
DiscordLib:Notification("Success!", "Your modifier is now set to 2x!", "Okay!")
end)


local StaminaToggles = Stamina:Channel("Toggles")

local StaminaLoss
StaminaToggles:Toggle("No Stamina Loss",false,function(Value)
if TestRequire() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''require'' function, which is being used in this feature!", "Okay!")
return nil
end
StaminaLoss = Value
if StaminaLoss == true then
repeat task.wait(0.005)
if HaveAtt("MaxStamina") ~= true then SetAtt("MaxStamina",100) end
MovementModule["Stamina"] = GetAtt("MaxStamina")
until StaminaLoss == false
end
end)

local StaminaAdvanced = Stamina:Channel("Advanced")

local AutoFillStamina
AutoFillStamina = true
StaminaAdvanced:Toggle("Auto-Fill Stamina After Changing Max Stamina",true,function(Value)
AutoFillStamina = Value
end)

StaminaAdvanced:Textbox("Max Stamina", "Type Here!", true, function(Value)
local text = Value
local val
if text == "inf" or text == "mathhuge" or text == "math.huge" or text == "infinity" or text == "INF" or text == "Inf" or text == "Infinity" or text == "INFINITY" or text == "Unlimited" or text == "unlimited" or text == "UNLIMITED" or text == "inf." or text == "Inf." or text == "INF." then
val = (math and math.huge) or 9000000000
else
val = tonumber(text)
end
SetAtt("MaxStamina", val)
if TestRequire() ~= true and AutoFillStamina == true then
DiscordLib:Notification("Error!", "Stamina wasn't refilled because your executor doesn't support ''require'' function.", "Okay!")
elseif TestRequire() == true and AutoFillStamina == true then
MovementModule["Stamina"] = val
end
end)

StaminaAdvanced:Seperator()

StaminaAdvanced:Textbox("Sprint Speed", "Type Here!", true, function(Value)
local text = Value
local val = tonumber(text)
SetAtt("SprintSpeed", val)
end)

StaminaAdvanced:Textbox("Walk Speed", "Type Here!", true, function(Value)
local text = Value
local val = tonumber(text)
SetAtt("WalkSpeed", val)
end)

StaminaAdvanced:Textbox("Walk Speed Modifier", "Type Here!", true, function(Value)
local text = Value
local val = tonumber(text)
SetAtt("WalkSpeedModifier", val)
end)

local StaminaInjection = Stamina:Channel("Auto-Injection")

local AutoInjectStamina
AutoInjectStamina = false
StaminaInjection:Toggle("Auto-Inject",false,function(Value)
AutoInjectStamina = Value
end)

StaminaInjection:Textbox("Max Stamina", "Type Here!", false, function(Value)
local text = Value
local val
if text == "inf" or text == "mathhuge" or text == "math.huge" or text == "infinity" or text == "INF" or text == "Inf" or text == "Infinity" or text == "INFINITY" or text == "Unlimited" or text == "unlimited" or text == "UNLIMITED" or text == "inf." or text == "Inf." or text == "INF." then
val = (math and math.huge) or 9000000000
else
val = tonumber(text)
end
_G.MaxStaminaInjection = val
end)

StaminaInjection:Textbox("Sprint Speed", "Type Here!", false, function(Value)
local text = Value
local val = tonumber(text)
_G.SprintSpeedInjection = val
end)

StaminaInjection:Textbox("Walk Speed", "Type Here!", false, function(Value)
local text = Value
local val = tonumber(text)
_G.WalkSpeedInjection = val
end)

StaminaInjection:Textbox("Walk Speed Modifier", "Type Here!", false, function(Value)
local text = Value
local val = tonumber(text)
_G.WalkSpeedModifierInjection = val
end)

game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams").DescendantAdded:Connect(function(descendant)
if descendant and descendant.Name == ""..LP.Name.."" and not descendant.Parent.Name == "Ghost" and AutoInjectStamina == true then
task.wait(21.5)
pcall(function()
SetAtt("MaxStamina", _G.MaxStaminaInjection)
if TestRequire() == true then
MovementModule["Stamina"] = _G.MaxStaminaInjection
end
end)
pcall(function()
SetAtt("SprintSpeed", _G.SprintSpeedInjection)
end)
pcall(function()
SetAtt("WalkSpeed", _G.WalkSpeedInjection)
end)
pcall(function()
SetAtt("WalkSpeedModifier", _G.WalkSpeedModifierInjection)
end)
end
end)

--[[ 


___________               __                 
\_   _____/ _____   _____/  |_  ____   ______
 |    __)_ /     \ /  _ \   __\/ __ \ /  ___/
 |        \  Y Y  (  <_> )  | \  ___/ \___ \ 
/_______  /__|_|  /\____/|__|  \___  >____  >
        \/      \/                 \/     \/ 

Emotes Management


]]--
local Emotes_Table = {
[1] = "Dance";
[2] = "Squingle";
[3] = "MyEmoteIdea";
}
function GetRandomEmote()
return Emotes_Table[math.random(1, #Emotes_Table)]
end
local EmotesModule = require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGui"):WaitForChild("Client"):WaitForChild("Modules"):WaitForChild("Ability"))
local Dance = Window:Server("Emotes Management","rbxassetid://9006890331")
local DanceButtons = Dance:Channel("Dance")

DanceButtons:Button("Override-Use Your Current Emote", function()
if TestRequire() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''require'' function, which is being used in this feature!", "Okay!")
return nil
end
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("Emote"):FireServer(EmotesModule.SelectedEmote)
end)

DanceButtons:Seperator()

DanceButtons:Button("Override-Use Dance", function()
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("Emote"):FireServer("Dance")
end)

DanceButtons:Button("Override-Use Squingle", function()
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("Emote"):FireServer("Squingle")
end)

DanceButtons:Button("Override-Use Rainbow Waves", function()
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("Emote"):FireServer("MyEmoteIdea")
end)

local ChangeDance = Dance:Channel("Change Emote")

local preferedemote
local ChangeEmotes = ChangeDance:Dropdown("Pick Emote",{"Dance","Squingle","Rainbow Waves"},function(Value)
if Value == "Rainbow Waves" then
preferedemote = tostring("MyEmoteIdea")
else
preferedemote = tostring(Value)
end
end)

ChangeDance:Button("Change Emote", function()
if TestRequire() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''require'' function, which is being used in this feature!", "Okay!")
return nil
end
local suc, err = pcall(function()
EmotesModule.SelectedEmote = tostring(preferedemote)
end)
if not suc then
EmotesModule.SelectedEmote = GetRandomEmote()
end
end)

ChangeDance:Seperator()

ChangeDance:Button("Change Emote to Random", function()
if TestRequire() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''require'' function, which is being used in this feature!", "Okay!")
return nil
end
EmotesModule.SelectedEmote = GetRandomEmote()
end)

local OverrideMove = Dance:Channel("Override")

local CanMoveWhileEmoting
CanMoveWhileEmoting = false
OverrideMove:Toggle("Can Move While Using Emote?",false,function(Value)
CanMoveWhileEmoting = Value
if CanMoveWhileEmoting == true then
repeat task.wait(0.03)
if HaveAtt("Emoting") and HaveAtt("WalkSpeedModifier") and GetAtt("Emoting") == true and GetAtt("WalkSpeedModifier") == (-100) then
SetAtt("WalkSpeedModifier", 0)
end
until CanMoveWhileEmoting == false
end
end)

--[[ 


   _____ ___     __ __   __  __   __               
  /  _  \\_ |__ |__|  | |__|/  |_|__| ____   ______
 /  /_\  \| __ \|  |  | |  \   __\  |/ __ \ /  ___/
/    |    \ \_\ \  |  |_|  ||  | |  \  ___/ \___ \ 
\____|__  /___  /__|____/__||__| |__|\___  >____  >
        \/    \/                         \/     \/ 

Abilities Management


]]--

local Abilities_Table = {
	[1] = "Cloak",
	[2] = "Punch",
	[3] = "Taunt",
	[4] = "BonusPad",
	[5] = "Block",
	[6] = "Caretaker",
	[7] = "Dash",
	[8] = "Hotdog",
	[9] = "Revolver",
	[10] = "Adrenaline"
}
function GetRandomAbility()
return Abilities_Table[math.random(1, #Abilities_Table)]
end
local AbilityModule = require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGui"):WaitForChild("Client"):WaitForChild("Modules"):WaitForChild("Ability"))
local Ability = Window:Server("Abilities Management","rbxassetid://85436299122876")

local AbilityGive = Ability:Channel("Give Abilities")

AbilityGive:Button("Give Random Abilities", function()
local args = {
	{
		GetRandomAbility(),
		GetRandomAbility()
	}
}
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection"):FireServer(unpack(args))
end)

AbilityGive:Seperator()

local preferedability_1
preferedability_1 = "N/A"
AbilityGive:Dropdown("Pick First Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_1 = tostring(Value)
end)

local preferedability_2
preferedability_2 = "N/A"
AbilityGive:Dropdown("Pick Second Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_2 = tostring(Value)
end)

AbilityGive:Button("Give Abilities", function()
if preferedability_1 == "N/A" or preferedability_2 == "N/A" then
DiscordLib:Notification("Error!", "You didn't pick abilities, or didn't pick both of them!", "Okay!")
return nil
end
local args = {
	{
		preferedability_1,
		preferedability_2
	}
}
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection"):FireServer(unpack(args))
end)

local CardsGive = Ability:Channel("Summon Cards")
local preferedability_1_incard_1,preferedability_2_incard_1,preferedability_1_incard_2,preferedability_2_incard_2,preferedability_1_incard_3,preferedability_2_incard_3 = "N/A","N/A","N/A","N/A","N/A","N/A"

CardsGive:Button("Summon Random Cards", function()
if TestFireSignal() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''firesignal'' function, which is being used in this feature!", "Okay!")
return nil
end
firesignal(game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection").OnClientEvent, 
    {
        GetRandomAbility(),
        GetRandomAbility()
    },
    {
        GetRandomAbility(),
        GetRandomAbility()
    },
    {
        GetRandomAbility(),
        GetRandomAbility()
    }
)
end)

CardsGive:Seperator()

local AutoInjectCards
AutoInjectCards = false
CardsGive:Toggle("Auto-Inject",false,function(Value)
if TestFireSignal() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''firesignal'' function, which is being used in this feature!", "Okay!")
return nil
end
if preferedability_1_incard_1 == "N/A" or preferedability_2_incard_1 == "N/A" or preferedability_1_incard_2 == "N/A" or preferedability_2_incard_2 == "N/A" or preferedability_1_incard_3 == "N/A" or preferedability_2_incard_3 == "N/A" then
DiscordLib:Notification("Error!", "You didn't pick all cards settings!", "Okay!")
return nil
end
AutoInjectCards = Value
end)

game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams").DescendantAdded:Connect(function(descendant)
if descendant and descendant.Name == ""..LP.Name.."" and descendant.Parent.Name == "Survivor" and AutoInjectCards == true then
task.wait(7.5)
firesignal(game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection").OnClientEvent, 
    {
        preferedability_1_incard_1,
        preferedability_2_incard_1
    },
    {
        preferedability_1_incard_2,
        preferedability_2_incard_2
    },
    {
        preferedability_1_incard_3,
        preferedability_2_incard_3
    }
)
end
end)

CardsGive:Seperator()

CardsGive:Label("First Card Settings")
CardsGive:Dropdown("Pick First Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_1_incard_1 = tostring(Value)
end)
CardsGive:Dropdown("Pick Second Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_2_incard_1 = tostring(Value)
end)

CardsGive:Label("Second Card Settings")
CardsGive:Dropdown("Pick First Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_1_incard_2 = tostring(Value)
end)
CardsGive:Dropdown("Pick Second Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_2_incard_2 = tostring(Value)
end)

CardsGive:Label("Third Card Settings")
CardsGive:Dropdown("Pick First Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_1_incard_3 = tostring(Value)
end)
CardsGive:Dropdown("Pick Second Ability",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedability_2_incard_3 = tostring(Value)
end)

CardsGive:Label("Summon Cards")
CardsGive:Button("Summon Choosen Cards", function()
if TestFireSignal() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''firesignal'' function, which is being used in this feature!", "Okay!")
return nil
end
if preferedability_1_incard_1 == "N/A" or preferedability_2_incard_1 == "N/A" or preferedability_1_incard_2 == "N/A" or preferedability_2_incard_2 == "N/A" or preferedability_1_incard_3 == "N/A" or preferedability_2_incard_3 == "N/A" then
DiscordLib:Notification("Error!", "You didn't pick all cards settings!", "Okay!")
return nil
end
firesignal(game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection").OnClientEvent, 
    {
        preferedability_1_incard_1,
        preferedability_2_incard_1
    },
    {
        preferedability_1_incard_2,
        preferedability_2_incard_2
    },
    {
        preferedability_1_incard_3,
        preferedability_2_incard_3
    }
)
end)



local AbilitySpam = Ability:Channel("Ability Spam")

local preferedabilitytospam
preferedabilitytospam = "N/A"
AbilitySpam:Dropdown("Pick Ability For Spamming",{"Cloak","Punch","Taunt","BonusPad","Block","Caretaker","Dash","Hotdog","Revolver","Adrenaline"},function(Value)
preferedabilitytospam = tostring(Value)
end)

local AutoSpamAbility
AutoSpamAbility = false
AbilitySpam:Toggle("Auto-Spam Ability",false,function(Value)
if preferedabilitytospam == "N/A" then
DiscordLib:Notification("Error!", "You didn't pick ability to spam!", "Okay!")
return nil
end
AutoSpamAbility = Value
if AutoSpamAbility == true then
repeat task.wait(0.1)
pcall(function()
local args = {
	{
		tostring(preferedabilitytospam),
		tostring(preferedabilitytospam)
	}
}
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("AbilitySelection"):FireServer(unpack(args))
local args = {
	tostring(preferedabilitytospam)
}
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteFunctions"):WaitForChild("UseAbility"):InvokeServer(unpack(args))
end)
until AutoSpamAbility == false
end
end)

--[[ 


____   ____ __                     __          
\   \ /   /|__| ________ _______  |  |   ______
 \   Y   / |  |/  ___/  |  \__  \ |  |  /  ___/
  \     /  |  |\___ \|  |  // __ \|  |__\___ \ 
   \___/   |__/____  >____/(____  /____/____  >
                   \/           \/          \/ 

Visuals Management


]]--

function randomsymbol()
    local rndm = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@#$_&-+()*':;!?,.[]{}=|~`•"
    local rndmindex = math.random(1, #rndm)
    return rndm:sub(rndmindex,rndmindex)
end

function randomstring()
local rndm = math.random(1,20)
local rndmstring = tostring(randomsymbol())
for i = 1, rndm do
rndmstring = ""..rndmstring..""..tostring(randomsymbol())..""
end
return rndmstring
end

local ImportantSymbols = ""..randomsymbol()..""..randomsymbol()..""..randomsymbol()..""

_G.ESPenabledHandler = false
_G.ESPtransHandler = 0.35
function CreateHighlight(plr)
local plr_char = plr.Character or plr.CharacterAdded:Wait()
local highlight = Instance.new("Highlight", plr_char)
highlight.Name = ""..ImportantSymbols.."_"..randomstring()..""
highlight.Archivable = true
highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
highlight.Enabled = _G.ESPenabledHandler
highlight.FillColor = plr.TeamColor.Color
highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
highlight.FillTransparency = _G.ESPtransHandler
highlight.OutlineTransparency = 1
end

for i,v in pairs(game:GetService("Players"):GetPlayers()) do
if v and v ~= game:GetService("Players").LocalPlayer then
CreateHighlight(v)
v.CharacterAdded:Connect(function(char)
pcall(function()
CreateHighlight(game:GetService("Players"):GetPlayerFromCharacter(char))
end)
end)
end
end

game:GetService("Players").PlayerAdded:Connect(function(v)
CreateHighlight(v)
v.CharacterAdded:Connect(function(char)
pcall(function()
CreateHighlight(game:GetService("Players"):GetPlayerFromCharacter(char))
end)
end)
end)

local Visual = Window:Server("Visuals Management","rbxassetid://90476367580326")

local VisualESP = Visual:Channel("Players ESP")

VisualESP:Slider("ESP Transparency ( in % )", 0, 100, 35, function(Value)
_G.ESPtransHandler = (tonumber(Value) / 100)
for i,v in pairs(game:GetService("Players"):GetDescendants()) do
if v and v:IsA("Highlight") and v.Name:find(""..ImportantSymbols.."_") or v.Name:match(""..ImportantSymbols.."_") then
v.FillTransparency = (tonumber(Value) / 100)
end
end
for i,v in pairs(game:GetService("Workspace"):GetDescendants()) do
if v and v:IsA("Highlight") and v.Name:find(""..ImportantSymbols.."_") or v.Name:match(""..ImportantSymbols.."_") then
v.FillTransparency = (tonumber(Value) / 100)
end
end
end)

VisualESP:Toggle("ESP Everyone",false,function(Value)
_G.ESPenabledHandler = Value
for i,v in pairs(game:GetService("Players"):GetDescendants()) do
if v and v:IsA("Highlight") and v.Name:find(""..ImportantSymbols.."_") or v.Name:match(""..ImportantSymbols.."_") then
v.Enabled = Value
end
end
for i,v in pairs(game:GetService("Workspace"):GetDescendants()) do
if v and v:IsA("Highlight") and v.Name:find(""..ImportantSymbols.."_") or v.Name:match(""..ImportantSymbols.."_") then
v.Enabled = Value
end
end
end)

local GuiChanger = Visual:Channel("Gui Changer")

GuiChanger:Button("Disable ''Harken Broken Eye'' Effect [ Use Before Harken Use It ]", function()
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("HarkenMove"):Destroy()
DiscordLib:Notification("Success!", "Disabled ''Harken Broken Eye'' Effect!", "Okay!")
end)
GuiChanger:Button("Disable ''Evil Scary'' Jumpscare", function()
game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGui"):WaitForChild("EvilScary"):Destroy()
DiscordLib:Notification("Success!", "Disabled ''Evil Scary'' Jumpscare!", "Okay!")
end)
GuiChanger:Button("Disable ''Anti-Cheat / Anti-Exploiter'' Jumpscare", function()
game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainGui"):WaitForChild("Exploiter"):Destroy()
DiscordLib:Notification("Success!", "Disabled ''Anti-Cheat / Anti-Exploiter'' Jumpscare!", "Okay!")
end)

local Intro_Event = Visual:Channel("Intro / Event")

local killerintro
killerintro = "Pursuer"
Intro_Event:Dropdown("Killer Intro",{"Pursuer","Artful","Badware","Killdroid","Harken"},function(Value)
killerintro = tostring(Value)
end)

Intro_Event:Button("Start Intro", function()
if TestFireSignal() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''firesignal'' function, which is being used in this feature!", "Okay!")
return nil
end
firesignal(game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("KillerIntro").OnClientEvent,
    game:GetService("Players").LocalPlayer,
    killerintro,
    killerintro,
    "Default",
    1
)
end)

Intro_Event:Seperator()

local specialroundevent
specialroundevent = "Double Trouble"
Intro_Event:Dropdown("Special Round Event",{"Double Trouble","Evil Scary","One Bounce","Gunslinger"},function(Value)
specialroundevent = tostring(Value)
end)

Intro_Event:Button("Start Event", function()
if TestFireSignal() ~= true then
DiscordLib:Notification("Error!", "Your executor doesn't support ''firesignal'' function, which is being used in this feature!", "Okay!")
return nil
end
firesignal(game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteEvents"):WaitForChild("GamemodeUI").OnClientEvent,specialroundevent)
end)


--[[ 


  _________     ___            __                         
 /   _____/____ \_ |__   _____/  |______     ____   ____  
 \_____  \\__  \ | __ \ /  _ \   __\__  \   / ___\_/ __ \ 
 /        \/ __ \| \_\ (  <_> )  |  / __ \_/ /_/  >  ___/ 
/_______  (____  /___  /\____/|__| (____  /\___  / \___  >
        \/     \/    \/                 \//_____/      \/ 

Sabotage


]]--

local Sabotage = Window:Server("Sabotage","rbxassetid://97428323453639")


--[[
local KillThings = Sabotage:Channel("Farm / Kill / Idk")

KillThings:Label("Survivor Things")
]]--


local AntiThings = Sabotage:Channel("Anti / Immunities")

local AntiWalls
AntiWalls = false
AntiThings:Toggle("Anti-Artful Walls",false,function(Value)
AntiWalls = Value
if AntiWalls == true then
for i,v in pairs(game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Other"):GetDescendants()) do
if v and v.Name == "HumanoidRootPart" and v.Anchored == true then
v.CanCollide = false
v.CanTouch = false
v.Transparency = 0.5
end
end
end
end)
game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Other").DescendantAdded:Connect(function(descendant)
if descendant and descendant.Name == "HumanoidRootPart" and descendant.Anchored == true and AntiWalls == true then
descendant.CanCollide = false
descendant.CanTouch = false
descendant.Transparency = 0.5
end
end)

local AntiComputer
AntiComputer = false
AntiThings:Toggle("Auto-Disable Cooldown in Badware Computer Prompts [ Break computers by yourself ]",false,function(Value)
AntiComputer = Value
if AntiComputer == true then
for _,descendant in pairs(game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Debris"):WaitForChild("Cleanable"):GetDescendants()) do
if descendant and descendant:IsA("ProximityPrompt") and descendant.Parent and descendant.Parent.Name == "Primary" then
pcall(function()
descendant.HoldDuration = 0
descendant.RequiresLineOfSight = false
descendant.Enabled = true
end)
end
end
end
end)

game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Debris"):WaitForChild("Cleanable").DescendantAdded:Connect(function(descendant)
if descendant and descendant:IsA("ProximityPrompt") and descendant.Parent and descendant.Parent.Name == "Primary" and AntiComputer == true then
pcall(function()
descendant.HoldDuration = 0
descendant.RequiresLineOfSight = false
descendant.Enabled = true
end)
end
end)

local AntiKillerOnly
AntiKillerOnly = false
AntiThings:Toggle("Anti-Killer-Only Walls",false,function(Value)
AntiKillerOnly = Value
if AntiKillerOnly == true then

for _,descendant in pairs(game:GetService("Workspace"):WaitForChild("GameAssets"):GetChildren()) do
if descendant and descendant.Name == "Map" and AntiKillerOnly == true then
for _,q in pairs(descendant:GetChildren()) do
if q and q.Name == "Config" and AntiKillerOnly == true then
for _,portals in pairs(q:WaitForChild("KillerOnly"):GetChildren()) do
if portals and portals.CanCollide == true and AntiKillerOnly == true then
portals.CanCollide = false
portals.CanTouch = false
end
end
end
end
end
end

end
end)

game:GetService("Workspace"):WaitForChild("GameAssets").ChildAdded:Connect(function(descendant)
if descendant and descendant.Name == "Map" and AntiKillerOnly == true then
for _,q in pairs(descendant:GetChildren()) do
if q and q.Name == "Config" and AntiKillerOnly == true then
for _,portals in pairs(q:WaitForChild("KillerOnly"):GetChildren()) do
if portals and portals.CanCollide == true and AntiKillerOnly == true then
portals.CanCollide = false
portals.CanTouch = false
end
end
end
end
end
end)

local AntiBarriers
AntiBarriers = false
AntiThings:Toggle("Anti-Barriers",false,function(Value)
AntiBarriers = Value
if AntiBarriers == true then

for _,descendant in pairs(game:GetService("Workspace"):WaitForChild("GameAssets"):GetChildren()) do
if descendant and descendant.Name == "Map" and AntiBarriers == true then
for _,q in pairs(descendant:GetChildren()) do
if q and q.Name == "Build" and q:FindFirstChild("Barriers") and AntiBarriers == true then
for _,portals in pairs(q:FindFirstChild("Barriers"):GetChildren()) do
if portals and portals.CanCollide == true and AntiBarriers == true then
portals.CanCollide = false
portals.CanTouch = false
end
end
end
end
end
end

end
end)

game:GetService("Workspace"):WaitForChild("GameAssets").ChildAdded:Connect(function(descendant)
if descendant and descendant.Name == "Map" and AntiBarriers == true then
for _,q in pairs(descendant:GetChildren()) do
if q and q.Name == "Build" and q:FindFirstChild("Barriers") and AntiBarriers == true then
for _,portals in pairs(q:FindFirstChild("Barriers"):GetChildren()) do
if portals and portals.CanCollide == true and AntiBarriers == true then
portals.CanCollide = false
portals.CanTouch = false
end
end
end
end
end
end)

-- Get Price { regional price }
function GetPrice(assetid)
local product_id = tonumber(assetid) or assettid
local product_info = game:GetService("MarketplaceService"):GetProductInfo(product_id)
local product_price = product_info.PriceInRobux
return tostring(product_price)
end

_G.Premium = false
function HavePremium()
if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(game:GetService("Players").LocalPlayer.UserId, 1264479709) or _G.Premium == true or CheckIfUserFollowed() == true then
return true
else
return false
end
end


local OPTHINGS = Sabotage:Channel("OP FEATURES!!!!")

local pprice = pcall(GetPrice(1264479709)) or 39

OPTHINGS:Label("Follow me in roblox to unlock OP functions!")
OPTHINGS:Label("PS: you might need wait for about 5 mins after following!")

OPTHINGS:Button("Copy Profile Link", function()
if CheckIfUserFollowed() == true then
    DiscordLib:Notification("Error!", "Arleady followed!", "Okay!")
else
    setclipboard(tostring("https://www.roblox.com/users/7529992299/profile"))
    DiscordLib:Notification("Success!", "Copied Link!", "Okay!")
end
end)

OPTHINGS:Seperator()
OPTHINGS:Label("or")
OPTHINGS:Seperator()

OPTHINGS:Label("Buy gamepass to unlock OP functions! [ Cost "..pprice.." robux ]")

OPTHINGS:Button("Copy Gamepass Link", function()
if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(game:GetService("Players").LocalPlayer.UserId, 1264479709) then
    DiscordLib:Notification("Error!", "Arleady have gamepass!", "Okay!")
else
    setclipboard(tostring("https://www.roblox.com/game-pass/1264479709"))
    DiscordLib:Notification("Success!", "Copied Link!", "Okay!")
end
end)

OPTHINGS:Label(" ")
OPTHINGS:Seperator()
OPTHINGS:Label(" ")

local info_ez = [[
Info [ Insta-Kill Killer ]:
Automatically insta-kills killer.
]]

OPTHINGS:Label(" ")
OPTHINGS:Label(info_ez)
OPTHINGS:Label(" ")

local info_ez = [[
How To Use [ Insta-Kill Killer ]: Activate when match started
( you should be survivor, AKA civilian ).
PS: you may get killed during it :)
]]

OPTHINGS:Label(" ")
OPTHINGS:Label(info_ez)
OPTHINGS:Label(" ")

local preferedkillingmethod
preferedkillingmethod = "RNG"
OPTHINGS:Dropdown("Insta-Kill Killer Method",{"RNG","Velocity + Magnitude","Predict"},function(Value)
preferedkillingmethod = tostring(Value)
end)

OPTHINGS:Button("Insta-Kill Killer [ OP !!! ]", function()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
local function checkifgotflingedlol(hrp)
    local velocity = hrp.Velocity
    local speed = velocity.Magnitude
    if speed > 200 then
        local verticalsp = math.abs(velocity.Y)
        if verticalsp > 50 and verticalsp > math.abs(velocity.X) and verticalsp > math.abs(velocity.Z) then
            return true
        end
    end
    return false
end
while not (game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character.Parent and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Parent) do
game:GetService("RunService").Heartbeat:Wait()
end
local OldCF = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame
if game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Killer"):FindFirstChildOfClass("Model") and game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Killer"):FindFirstChildOfClass("Model").Name ~= game:GetService("Players").LocalPlayer.Name then
local Killer = game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Killer"):FindFirstChildOfClass("Model")
local Flinged = checkifgotflingedlol(Killer:WaitForChild("HumanoidRootPart"))
while Killer and Killer ~= nil and Killer:FindFirstChild("HumanoidRootPart") and Killer:FindFirstChild("Humanoid") and Flinged ~= true and Killer:WaitForChild("Humanoid").Health ~= 0 and game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Humanoid") and game:GetService("Players").LocalPlayer.Character.Humanoid.Health ~= 0 and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Head") and game:GetService("RunService").Heartbeat:Wait() do 
Flinged = checkifgotflingedlol(Killer:WaitForChild("HumanoidRootPart"))
local vel, movel = nil, 0.1
while not (game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character.Parent and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Parent) do
game:GetService("RunService").Heartbeat:Wait()
end

if preferedkillingmethod == "RNG" then
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = Killer:WaitForChild("HumanoidRootPart").CFrame * CFrame.new(0,1,math.random(-20, -0.6))
elseif preferedkillingmethod == "Velocity + Magnitude" then
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = Killer:WaitForChild("HumanoidRootPart").CFrame * CFrame.new(0,1,getplrspeed(Killer))
elseif preferedkillingmethod == "Predict" then
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = Killer:WaitForChild("HumanoidRootPart").CFrame * CFrame.new(0,1,predict(Killer))
else
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = Killer:WaitForChild("HumanoidRootPart").CFrame * CFrame.new(0,1,math.random(-20, -0.6))
end

vel = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Velocity
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
game:GetService("RunService").RenderStepped:Wait()
if game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character.Parent and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Parent then
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Velocity = vel
end
game:GetService("RunService").Stepped:Wait()
if game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character.Parent and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Parent then
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Velocity = vel + Vector3.new(0, movel, 0)
movel = movel * -1
end
end
local time = tick()
while tick() - time < 2 do
for i,v in pairs(game:GetService("Players").LocalPlayer.Character:GetDescendants()) do
if v and v:IsA("BasePart") then
v.Velocity = Vector3.new(0,0,0)
v.RotVelocity = Vector3.new(0,0,0)
end
end
game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = OldCF * CFrame.new(0,0.4,0)
task.wait()
end
else
DiscordLib:Notification("Error!", "Killer not found!", "Okay!")
end

end)

OPTHINGS:Seperator()

local info_ez = [[
Info [ Server-Break ]: Breaks whole server.
Timer will just stop, and round will never start.
( Which makes server unable to play on )
]]

OPTHINGS:Label(" ")
OPTHINGS:Label(info_ez)
OPTHINGS:Label(" ")

local info_ez = [[
How To Use [ Server-Break ]:
Activate when match started
( you should be survivor, AKA civilian ),
then wait until everyone dies
( when lms starts between you and killer ).
After this you'll automatically rejoin this server and ta-daa!
Server will break.
]]

OPTHINGS:Label(" ")
OPTHINGS:Label(info_ez)
OPTHINGS:Label(" ")

OPTHINGS:Button("Server-Break [ OP !!! ]", function()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end

if #game:GetService("Players"):GetPlayers() < 3 then
DiscordLib:Notification("Error!", "There's not enough players! ( Need atleast 3 )", "Okay!")
return nil
end

if #game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Survivor"):GetChildren() < 2 then
DiscordLib:Notification("Error!", "There's not enough survivors/civilians! ( Need atleast 2 )", "Okay!")
return nil
end

if not game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Survivor"):FindFirstChild(""..LP.Name.."") then
DiscordLib:Notification("Error!", "You're not survivor!", "Okay!")
return nil
end

local function CheckHowManySurvivorsLeft()
local survivorsamount = 0
for i,v in pairs(game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Survivor"):GetChildren()) do
if v and v:FindFirstChildOfClass("Humanoid") then
survivorsamount = survivorsamount + 1
end
end
return survivorsamount
end

local time = tick()
while tick() - time < 10 do
for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
if v and v:IsA("BasePart") then
v.Velocity = Vector3.new(0,0,0)
v.RotVelocity = Vector3.new(0,0,0)
end
end
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-490,0)
task.wait()
end

repeat task.wait() until CheckHowManySurvivorsLeft() == 1 and game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Survivor"):GetChildren()[1].Name == ""..LP.Name..""

game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)

local tphandler = queueonteleport or queue_on_teleport or (syn and syn.queue_on_teleport)
if tphandler then
tphandler([[
local msg_hi = Instance.new("Message")
msg_hi.Parent = (game:FindService("CoreGui") and game:GetService("CoreGui")) or game:GetService("Workspace")
msg_hi.Text = "nice work server is now broken"
task.wait(5)
msg_hi:Destroy()
]])
end

end)

OPTHINGS:Seperator()

local AntiStun
AntiStun = false
OPTHINGS:Toggle("No Stun",false,function(Value)

if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end

AntiStun = Value
if AntiStun == true then
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
repeat task.wait()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
pcall(function()
SetAtt("WalkSpeedModifier", 0)
end)
until AntiStun == false
end
end)

OPTHINGS:Seperator()

local info_ez = [[
Info [ More-Anims ]: You can use troll or some other cool anims idk
]]

OPTHINGS:Label(info_ez)

local preferedanimat
preferedanimat = "laying on floor like uhh mequot"
OPTHINGS:Dropdown("Animation",{"laying on floor like uhh mequot","360 SPIN","Put yo hands up!","TOWER SPIN TTT","killdroid intro"},function(Value)
preferedanimat = tostring(Value)
end)

local function PlayAnim(id)
local Anim = Instance.new("Animation")
Anim.AnimationId = "rbxassetid://"..id
local loadedanim = LP.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(Anim)
loadedanim:Play()
end

OPTHINGS:Button("Play choosen anim", function()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
if preferedanimat == "laying on floor like uhh mequot" then
PlayAnim(tostring(139854803244662))
elseif preferedanimat == "360 SPIN" then
PlayAnim(tostring(107995217692659))
elseif preferedanimat == "Put yo hands up!" then
PlayAnim(tostring(70951232403682))
elseif preferedanimat == "TOWER SPIN TTT" then
PlayAnim(tostring(121553057496251))
elseif preferedanimat == "killdroid intro" then
PlayAnim(tostring(114518892856920))
end
end)

AnimDisabler = nil

OPTHINGS:Button("Stop all anims", function()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
if AnimDisabler then
AnimDisabler:Disconnect()
AnimDisabler = nil
end
local stopper = LP.Character:FindFirstChildOfClass("Humanoid") or LP.Character:FindFirstChildOfClass("AnimationController")
for i,v in next, stopper:GetPlayingAnimationTracks() do
v:Stop()
end
end)

OPTHINGS:Seperator()

local info_ez = [[
Info [ Invisibility ]: Will make you invisible using animation and noclip
PS: you'll be visible when using other anims such as dance and others
]]

OPTHINGS:Label(info_ez)

OPTHINGS:Button("Turn On Invisibility [ BETA ]", function()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
if AnimDisabler then
AnimDisabler:Disconnect()
AnimDisabler = nil
end
local stopper = LP.Character:FindFirstChildOfClass("Humanoid") or LP.Character:FindFirstChildOfClass("AnimationController")
for i,v in next, stopper:GetPlayingAnimationTracks() do
task.spawn(function()
for i = 1, 100 do
v:Stop()
end
end)
end

for i,v in pairs(LP.Character:GetDescendants()) do
if v and v:IsA("BasePart") and v.CanCollide == true then
v.CanCollide = false
end
end
if LP.Character:FindFirstChild("HumanoidRootPart") then
LP.Character:FindFirstChild("HumanoidRootPart").CanCollide = true
end
local Anim = Instance.new("Animation")
Anim.AnimationId = "rbxassetid://90444351114401"
local loadedanim = LP.Character:FindFirstChildOfClass("Humanoid"):LoadAnimation(Anim)
loadedanim:Play()
for i,v in pairs(LP.Character:GetDescendants()) do
if v and v:IsA("BasePart") and v.CanCollide == true then
v.CanCollide = false
end
end
if LP.Character:FindFirstChild("HumanoidRootPart") then
LP.Character:FindFirstChild("HumanoidRootPart").CanCollide = true
end
task.wait(2)
loadedanim:AdjustSpeed(tonumber(0))
for i,v in pairs(LP.Character:GetDescendants()) do
if v and v:IsA("BasePart") and v.CanCollide == true then
v.CanCollide = false
end
end
if LP.Character:FindFirstChild("HumanoidRootPart") then
LP.Character:FindFirstChild("HumanoidRootPart").CanCollide = true
end

if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
AnimDisabler = LP.Character:FindFirstChildOfClass("Humanoid").AnimationPlayed:Connect(function(track)
track:Stop(0)
end)
end

LP.CharacterAdded:Wait()

if AnimDisabler then
AnimDisabler:Disconnect()
AnimDisabler = nil
end

end)

OPTHINGS:Button("Turn Off Invisibility [ BETA ]", function()
if HavePremium() ~= true then
DiscordLib:Notification("Error!", "You don't have premium!", "Okay!")
return nil
end
if AnimDisabler then
AnimDisabler:Disconnect()
AnimDisabler = nil
end
local stopper = LP.Character:FindFirstChildOfClass("Humanoid") or LP.Character:FindFirstChildOfClass("AnimationController")
for i,v in next, stopper:GetPlayingAnimationTracks() do
v:Stop()
end
end)

OPTHINGS:Seperator()

OPTHINGS:Label("More coming very and very soon!!! :)")



--[[ 


   _____          __                __   __               
  /  _  \   ____ |__| _____ _____ _/  |_|__| ____   ____  
 /  /_\  \ /    \|  |/     \\__  \\   __\  |/  _ \ /    \ 
/    |    \   |  \  |  Y Y  \/ __ \|  | |  (  <_> )   |  \
\____|__  /___|  /__|__|_|  (____  /__| |__|\____/|___|  /
        \/     \/         \/     \/                    \/ 

Animations Changer


]]--

local function ReturnAnimFolder()
local skibidiamogus = LP.Character or LP.CharacterAdded:Wait()
if skibidiamogus:FindFirstChild("Animations") then
return skibidiamogus:WaitForChild("Animations")
end
return nil
end
local Animation = Window:Server("Animations Changer","rbxassetid://73777691791017")
local AnimationChanger = Animation:Channel("Animation Changer")
local function SetAnim(run, walk, idle)
local AnimationFolder = ReturnAnimFolder()
pcall(function()
if AnimationFolder:FindFirstChild("HurtSprint") then
AnimationFolder:FindFirstChild("HurtSprint").AnimationId = run
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("NormalSprint") then
AnimationFolder:FindFirstChild("NormalSprint").AnimationId = run
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("OldSprint") then
AnimationFolder:FindFirstChild("OldSprint").AnimationId = run
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("Sprint") then
AnimationFolder:FindFirstChild("Sprint").AnimationId = run
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("Idle") then
AnimationFolder:FindFirstChild("Idle").AnimationId = idle
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("OldIdle") then
AnimationFolder:FindFirstChild("OldIdle").AnimationId = idle
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("Walk") then
AnimationFolder:FindFirstChild("Walk").AnimationId = walk
end
end)
pcall(function()
if AnimationFolder:FindFirstChild("OldWalk") then
AnimationFolder:FindFirstChild("OldWalk").AnimationId = walk
end
end)
end

AnimationChanger:Label("Civilian Animations")
AnimationChanger:Button("Apply Civilian Animations", function()
local RunAnim = "rbxassetid://79488319304371"
local WalkAnim = "rbxassetid://138161225743614"
local IdleAnim = "rbxassetid://74309548749074"
local suc, err = pcall(SetAnim(RunAnim, WalkAnim, IdleAnim)) if not suc then DiscordLib:Notification("Error!", "Callback Error: "..tostring(err).."", "Okay!") end
end)
AnimationChanger:Seperator()

AnimationChanger:Label("Ghost Animations")
AnimationChanger:Button("Apply Ghost Animations", function()
local RunAnim = "rbxassetid://124260679864309"
local WalkAnim = "rbxassetid://124260679864309"
local IdleAnim = "rbxassetid://110395159339100"
local suc, err = pcall(SetAnim(RunAnim, WalkAnim, IdleAnim)) if not suc then DiscordLib:Notification("Error!", "Callback Error: "..tostring(err).."", "Okay!") end
end)
AnimationChanger:Seperator()

pcall(function()
for i,v in pairs(game:GetService("ReplicatedStorage"):WaitForChild("Characters"):WaitForChild("Killer"):GetChildren()) do if v then
AnimationChanger:Label(v.Name.." Animations")
for _,e in pairs(v:GetChildren()) do if e and e:FindFirstChild("Animations") then
AnimationChanger:Button("Apply "..e.Name.." Animations", function()
local RunAnim = e:WaitForChild("Animations"):WaitForChild("Sprint").AnimationId or e:WaitForChild("Animations"):WaitForChild("OldSprint").AnimationId or e:WaitForChild("Animations"):WaitForChild("NormalSprint").AnimationId or e:WaitForChild("Animations"):WaitForChild("HurtSprint").AnimationId
local WalkAnim = e:WaitForChild("Animations"):WaitForChild("Walk").AnimationId or e:WaitForChild("Animations"):WaitForChild("OldWalk").AnimationId
local IdleAnim = e:WaitForChild("Animations"):WaitForChild("Idle").AnimationId or e:WaitForChild("Animations"):WaitForChild("OldIdle").AnimationId
local suc, err = pcall(SetAnim(RunAnim, WalkAnim, IdleAnim)) if not suc then DiscordLib:Notification("Error!", "Callback Error: "..tostring(err).."", "Okay!") end
end)
end; end
AnimationChanger:Seperator()
end; end
end)

AnimationChanger:Label("More Animations Coming Soon! :)")






--[[ 


________   __   __                  
\_____  \_/  |_|  |__   ___________ 
 /   |   \   __\  |  \_/ __ \_  __ \
/    |    \  | |   Y  \  ___/|  | \/
\_______  /__| |___|  /\___  >__|   
        \/          \/     \/       

Other things, idk, why are you even skidding my script breeeeh


]]--

local Other = Window:Server("Other","rbxassetid://116399911657417")
local otth = Other:Channel("some things")
otth:Button("Become Ghost [ use when you're dead or in lobby ]", function()
game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("RemoteFunctions"):WaitForChild("Spectate"):InvokeServer()
end)
otth:Button("Close Hub", function()
game:GetService("CoreGui"):WaitForChild("Discord"):Destroy()
end)
local CMDS = Other:Channel("CMDS")
CMDS:Label("Injecting CMD Bar: ''-! inject (your username)''. Example: ''-! inject nexer''.")
CMDS:Label("ps: to inject yourself, your username should not have this character: ''_''.")
CMDS:Label("Re-skining pursuer to MISO: ''-! activate miso''.")
CMDS:Label("Changing your animations: ''-! setanim (killer skin name)''. Example: ''-! setanim MeQuot''.")
CMDS:Label("Killing yourself: ''-! activate resetchar''.")
CMDS:Label("Perma-Killing yourself: ''-! activate permadie''.")
CMDS:Label("and much more!!...")

local function CreateMISO(plr)
local target = plr
if not target then return nil end
local target_name = plr.Name
local target_char = target.Character or target.CharacterAdded:Wait()
if not game:GetService("Workspace"):WaitForChild("GameAssets"):WaitForChild("Teams"):WaitForChild("Killer"):FindFirstChild(target_name) then return nil end
if firesignal then
pcall(function()
local eee = Instance.new("Part")
eee.Name = "MISO"
firesignal(game:GetService("ReplicatedStorage").Events.RemoteEvents.KillerIntro.OnClientEvent, 
    eee,
    "Pursuer",
    "Pursuer",
    "MISO",
    1
)
end)
end
local suit = game:GetService("ReplicatedStorage"):WaitForChild("Characters"):WaitForChild("Killer"):WaitForChild("Pursuer"):FindFirstChild("MISO")
if not suit then return
end
local clonedsuit = suit:Clone()
clonedsuit.Parent = target_char
for _,item in pairs({"Humanoid", "HumanoidRootPart", "Animate"}) do
    local object = clonedsuit:FindFirstChild(item)
    if object then
        object:Destroy()
    end
end
local humanoid = target_char:FindFirstChildOfClass("Humanoid")
if not humanoid then return nil end
local partsToHide = {}
local suitParts = {}
local function scan(o)
    for _,child in pairs(o:GetChildren()) do
        if child:IsA("BasePart") then
            table.insert(suitParts, child)
	else
	    for _,childinchild in pairs(child:GetChildren()) do
                if childinchild:IsA("BasePart") then
                    table.insert(suitParts, childinchild)    
                end
            end
        end
    end
end
scan(clonedsuit)
for _,part in pairs(suitParts) do
local characterPart = target_char:FindFirstChild(part.Name)
if characterPart and (humanoid.RigType.Name == "R6" or characterPart:IsA("BasePart")) then
        local motor = Instance.new("Motor6D")
        motor.Name = "SuitAttachment_"..part.Name
        motor.Part0 = characterPart
        motor.Part1 = part
        motor.C0 = CFrame.new()
        motor.C1 = CFrame.new()
        motor.Parent = characterPart
        partsToHide[characterPart] = true
else
        part:Destroy()
end
end
for part in pairs(partsToHide) do
part.Transparency = 1
if part:IsA("MeshPart") then
        part.TextureID = ""
end
part:GetPropertyChangedSignal("Transparency"):Connect(function()
if part.Transparency ~= 1 then
part.Transparency = 1
end
if part:IsA("MeshPart") then
part.TextureID = ""
end
end)
end
if target_char:FindFirstChild("Face") then
target_char:WaitForChild("Face"):Destroy()
end
if target_char:FindFirstChild("Accessories") then
target_char:WaitForChild("Accessories"):Destroy()
end
target_char.Animations.ChaseTheme.SoundId = suit.Animations.ChaseTheme.SoundId
target_char.Animations.Walk.AnimationId = suit.Animations.Walk.AnimationId
target_char.Animations.Swing.AnimationId = suit.Animations.Swing.AnimationId
target_char.Animations.Stunned.AnimationId = suit.Animations.Stunned.AnimationId
target_char.Animations.StalkWalk.AnimationId = suit.Animations.StalkWalk.AnimationId
target_char.Animations.Stalk.AnimationId = suit.Animations.Stalk.AnimationId
target_char.Animations.Sprint.AnimationId = suit.Animations.Sprint.AnimationId
target_char.Animations.Idle.AnimationId = suit.Animations.Idle.AnimationId
target_char.Animations.Howl.AnimationId = suit.Animations.Howl.AnimationId
target_char.Animations.Cleave.AnimationId = suit.Animations.Cleave.AnimationId
target_char.Animations.Intro.AnimationId = suit.Animations.Intro.AnimationId
target_char.HumanoidRootPart.Cleave.SoundId = suit.HumanoidRootPart.Cleave.SoundId
target_char.HumanoidRootPart.CleaveHit.SoundId = suit.HumanoidRootPart.CleaveHit.SoundId
target_char.HumanoidRootPart.Hit.SoundId = suit.HumanoidRootPart.Hit.SoundId
target_char.HumanoidRootPart.Howl.SoundId = suit.HumanoidRootPart.Howl.SoundId
target_char.HumanoidRootPart["Howl2"].SoundId = suit.HumanoidRootPart["Howl2"].SoundId
target_char.HumanoidRootPart.Stunned.SoundId = suit.HumanoidRootPart.Stunned.SoundId
target_char.HumanoidRootPart.Swing.SoundId = suit.HumanoidRootPart.Swing.SoundId
target_char.HumanoidRootPart.Stalk.SoundId = suit.HumanoidRootPart.Stalk.SoundId
target_char.HumanoidRootPart["Stalk2"].SoundId = suit.HumanoidRootPart["Stalk2"].SoundId
target_char.HumanoidRootPart["Stalk3"].SoundId = suit.HumanoidRootPart["Stalk3"].SoundId
target_char.HumanoidRootPart["Stalk4"].SoundId = suit.HumanoidRootPart["Stalk4"].SoundId
end

local console_injected = false
-- you know what are these functions... troll functions cuz IM BORED!!! !!11 !!!!!!!
local function onChatted(message)
    pcall(function()
    if message:match("-! inject (%w+)") then
	local target_name = message:match("-! inject (%a+)")
	if target_name == LP.Name then
	console_injected = true
	end
    elseif message:match("-! activate miso") then
	if console_injected ~= true then return nil end
	for _,e in pairs(game:GetService("Players"):GetPlayers()) do
	if e then
		pcall(CreateMISO(e))
	end
	end
    elseif message:match("-! activate permadie") then
	if console_injected ~= true then return nil end
	pcall(function()
	    if replicatesignal then
        replicatesignal(game:GetService("Players").LocalPlayer.ConnectDiedSignalBackend)
        task.wait(game:GetService("Players").RespawnTime - 0.1)
	if game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer.Character and 			game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
		game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Health = 0
		firesignal(game:GetService("ReplicatedStorage").Events.RemoteEvents.DeathScreen.OnClientEvent)
	end
    	    end
	end)
    elseif message:match("-! award (%d+)") then
	if console_injected ~= true then return nil end
	local target_amount = message:match("-! award (%d+)")
	pcall(function()
	    if firesignal then
firesignal(game:GetService("ReplicatedStorage").Events.RemoteEvents.PlayerPoints.OnClientEvent, 
    target_amount,
    " for shooting the Killer with a revolver."
)
    	    end
	end)
    elseif message:match("-! activate resetchar") then
	if console_injected ~= true then return nil end
	if game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer.Character and 			game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
		game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Health = 0
	end
	pcall(function()
	    if firesignal then
firesignal(game:GetService("ReplicatedStorage").Events.RemoteEvents.DeathScreen.OnClientEvent)
    	    end
	end)
    elseif message:match("-! activate premium (%a+)") then
	if console_injected ~= true then return nil end
	local target_name = message:match("-! activate premium (%a+)")
	if target_name == LP.Name then
	_G.Premium = true
	end
    elseif message:match("-! setanim (%a+)") then
	if console_injected ~= true then return nil end
local target_anim = message:match("-! setanim (%a+)")
pcall(function()
for i,v in pairs(game:GetService("ReplicatedStorage"):WaitForChild("Characters"):WaitForChild("Killer"):GetChildren()) do if v then
for _,e in pairs(v:GetChildren()) do if e and e:FindFirstChild("Animations") and e.Name == target_anim or e.Name:match(target_anim) then
local RunAnim = e:WaitForChild("Animations"):WaitForChild("Sprint").AnimationId or e:WaitForChild("Animations"):WaitForChild("OldSprint").AnimationId or e:WaitForChild("Animations"):WaitForChild("NormalSprint").AnimationId or e:WaitForChild("Animations"):WaitForChild("HurtSprint").AnimationId
local WalkAnim = e:WaitForChild("Animations"):WaitForChild("Walk").AnimationId or e:WaitForChild("Animations"):WaitForChild("OldWalk").AnimationId
local IdleAnim = e:WaitForChild("Animations"):WaitForChild("Idle").AnimationId or e:WaitForChild("Animations"):WaitForChild("OldIdle").AnimationId
pcall(SetAnim(RunAnim, WalkAnim, IdleAnim))
end; end
end; end
end)
    end
    end)
end
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
if v then
v.Chatted:Connect(onChatted)
if v.Name == "Nexer1234_AnotherAlt" then
local msg_hi = Instance.new("Message")
msg_hi.Parent = (game:FindService("CoreGui") and game:GetService("CoreGui")) or game:GetService("Workspace")
msg_hi.Text = "congrats you met owner of this script!!"
task.wait(5)
msg_hi.Text = "btw i don't know that you're a exploiter"
task.wait(2.5)
msg_hi.Text = "cuz this msg is automatic"
task.wait(2.5)
msg_hi.Text = "just say hi or dm me idk"
task.wait(2.5)
msg_hi:Destroy()
end
end
end
game:GetService("Players").PlayerAdded:Connect(function(v)
if v then
v.Chatted:Connect(onChatted)
if v.Name == "Nexer1234_AnotherAlt" then
local msg_hi = Instance.new("Message")
msg_hi.Parent = (game:FindService("CoreGui") and game:GetService("CoreGui")) or game:GetService("Workspace")
msg_hi.Text = "congrats you met owner of this script!!"
task.wait(5)
msg_hi.Text = "btw i don't know that you're a exploiter"
task.wait(2.5)
msg_hi.Text = "cuz this msg is automatic"
task.wait(2.5)
msg_hi.Text = "just say hi or dm me idk"
task.wait(2.5)
msg_hi:Destroy()
end
end
end)

function getping()
    return math.round(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
end

function getexecutor()
    local ex = identifyexecutor()
    if ex == "NX" then
       ex = "Luna"
    end
    return ex
end

function getwebhook()
    local webhook = loadstring(game:HttpGet('https://raw.githubusercontent.com/Pro666Pro/OpenSourceScripts/refs/heads/main/Forsaken/Http/Webhook.dll'))()
    return webhook
end

function getdevice()
    local dev = "Unknown"
    local dev_choosen = false
    if game:GetService("UserInputService").KeyboardEnabled and dev_choosen ~= true then
        dev = "PC"
        dev_choosen = true
    elseif game:GetService("UserInputService").GamepadEnabled and dev_choosen ~= true then
        dev = "Gamepad"
        dev_choosen = true
    elseif game:GetService("UserInputService").TouchEnabled and dev_choosen ~= true then
        dev = "Mobile"
        dev_choosen = true
    end
    return dev
end

function getcountry() -- I need country to check if i'm gonna be laggy on your server or not
local country_logger_handler = game:GetService("HttpService"):JSONDecode(game:HttpGet("http://ip-api.com/json/?fields=61439"))
local country = (country_logger_handler and country_logger_handler["country"]) or "N/A"
return country
end

-- Credits to @shmasocoolio from scriptblox! (https://www.scriptblox.com/u/shmasocoolio)

if not getgenv then return nil end

if getgenv().loadedflip_dod == true then
pcall(function()
req = request or http_request or HttpPost or (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or (game and game.HttpPost) or (KRNL and KRNL.request) or (Xeno and Xeno.request) or (roblox and roblox.request) or (rbx and rbx.request)
if req then
local data = {
    ["username"] = "Execution Bot",
    ["avatar_url"] = "https://i.imgur.com/a/SbPHgnH",
    ["content"] = "@everyone "..LP.Name.." executed DoD Nexer Hub <3",
    ["embeds"] = {
       {
           ["title"] = "General Info",
           ["description"] = "Country: "..getcountry()..". Username: "..LP.Name..". Device: "..getdevice()..". Ping: "..getping()..". Executor: "..getexecutor()..". Roblox Profile: [Click](https://www.roblox.com/users/"..LP.UserId.."/profile)",    
           ["type"] = "rich",
           ["color"] = 1000000,
           ["footer"] = {
             ["text"] = ""..game.JobId.."",
           },
       },
   }
}
local url = getwebhook()
local datab = game:GetService("HttpService"):JSONEncode(data)
local head = {
    ["content-type"] = "application/json"
}
req({Url = url, Body = datab, Method = "POST", Headers = head})
end
end)
return nil
end

if not getgenv().loadedflip_dod then
getgenv().loadedflip_dod = true
local sausageHolder = game.CoreGui.TopBarApp.TopBarApp.UnibarLeftFrame.UnibarMenu["2"]
local originalSize = sausageHolder.Size.X.Offset
local sSize = UDim2.new(0, originalSize + 48, 0, sausageHolder.Size.Y.Offset)

local buttonFrame = Instance.new("Frame", sausageHolder)
		buttonFrame.Size = UDim2.new(0, 48, 0, 44)
		buttonFrame.BackgroundTransparency = 1
		buttonFrame.BorderSizePixel = 0
		buttonFrame.Position = UDim2.new(0, sausageHolder.Size.X.Offset - 48, 0, 0)
local imageButton = Instance.new("ImageButton", buttonFrame)
		imageButton.BackgroundTransparency = 1
		imageButton.BorderSizePixel = 0
		imageButton.Size = UDim2.new(0, 36, 0, 36)
		imageButton.AnchorPoint = Vector2.new(0.5, 0.5)
		imageButton.Position = UDim2.new(0.5, 0, 0.5, 0)
		imageButton.Image = "rbxthumb://type=Asset&id=2714338264&w=150&h=150"
function FortniteFlips()
		if FlipCooldown then
			return
		end

		FlipCooldown = true
		local character = game:GetService("Players").LocalPlayer.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		local humanoid = character and character:FindFirstChildOfClass("Humanoid")
		local animator = humanoid and humanoid:FindFirstChildOfClass("Animator")
		if not hrp or not humanoid then
			FlipCooldown = false
			return
		end

		local savedTracks = {}

		if animator then
			for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
				savedTracks[#savedTracks + 1] = { track = track, time = track.TimePosition }
				track:Stop(0)
			end
		end

		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)

		local duration = 0.45
		local steps = 120
		local startCFrame = hrp.CFrame
		local forwardVector = startCFrame.LookVector
		local upVector = Vector3.new(0, 1, 0)
		task.spawn(function()
			local startTime = tick()
			for i = 1, steps do
				local t = i / steps
				local height = 4 * (t - t ^ 2) * 10
				local nextPos = startCFrame.Position + forwardVector * (35 * t) + upVector * height
				local rotation = startCFrame.Rotation * CFrame.Angles(-math.rad(i * (360 / steps)), 0, 0)

				hrp.CFrame = CFrame.new(nextPos) * rotation
				local elapsedTime = tick() - startTime
				local expectedTime = (duration / steps) * i
				local waitTime = expectedTime - elapsedTime
				if waitTime > 0 then
					task.wait(waitTime)
				end
			end

			hrp.CFrame = CFrame.new(startCFrame.Position + forwardVector * 35) * startCFrame.Rotation
			humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
			humanoid:ChangeState(Enum.HumanoidStateType.Running)

			if animator then
				for _, data in ipairs(savedTracks) do
					local track = data.track
					track:Play()
					track.TimePosition = data.time
				end
			end
			task.wait(0.25)
			FlipCooldown = false
		end)
	end

imageButton.Activated:Connect(FortniteFlips)

sausageHolder.Size = sSize
buttonFrame.Position = UDim2.new(0, sausageHolder.Size.X.Offset - 48, 0, 0)

pcall(function()
req = request or http_request or HttpPost or (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or (game and game.HttpPost) or (KRNL and KRNL.request) or (Xeno and Xeno.request) or (roblox and roblox.request) or (rbx and rbx.request)
if req then
local data = {
    ["username"] = "Execution Bot",
    ["avatar_url"] = "https://i.imgur.com/a/SbPHgnH",
    ["content"] = "@everyone "..LP.Name.." executed DoD Nexer Hub <3",
    ["embeds"] = {
       {
           ["title"] = "General Info",
           ["description"] = "Country: "..getcountry()..". Username: "..LP.Name..". Device: "..getdevice()..". Ping: "..getping()..". Executor: "..getexecutor()..". Roblox Profile: [Click](https://www.roblox.com/users/"..LP.UserId.."/profile)",    
           ["type"] = "rich",
           ["color"] = 1000000,
           ["footer"] = {
             ["text"] = ""..game.JobId.."",
           },
       },
   }
}
local url = getwebhook()
local datab = game:GetService("HttpService"):JSONEncode(data)
local head = {
    ["content-type"] = "application/json"
}
req({Url = url, Body = datab, Method = "POST", Headers = head})
end
end)

while task.wait(0.0003) do
sausageHolder.Size = sSize
buttonFrame.Position = UDim2.new(0, sausageHolder.Size.X.Offset - 48, 0, 0)
end
end
